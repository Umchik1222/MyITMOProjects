<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Множество Жюлиа</title>
    <style>
        body {
            margin: 0;
            display: flex;
        }
        #canvas-container {
            position: relative;
            flex-grow: 1;
        }
        #juliaCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #controls {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background-color: #f0f0f0;
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .control-group input[type="range"],
        .control-group input[type="text"] {
            width: 100%;
        }
        #resetButton {
            display: block;
            width: 100%;
            padding: 10px;
            font-size: 16px;
            background-color: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        #resetButton:hover {
            background-color: #005fa3;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="juliaCanvas"></canvas>
</div>

<div id="controls">
    <div class="control-group">
        <label for="cReal">Действительная часть c: <span id="cRealValue">-0.7</span></label>
        <input type="range" id="cReal" min="-2.0" max="2.0" value="-0.7" step="0.01">
    </div>
    <div class="control-group">
        <label for="cImag">Мнимая часть c: <span id="cImagValue">0.27015</span></label>
        <input type="range" id="cImag" min="-2.0" max="2.0" value="0.27015" step="0.01">
    </div>
    <div class="control-group">
        <label for="iterations">Макс. итераций: <span id="iterationsValue">100</span></label>
        <input type="range" id="iterations" min="50" max="2000" value="100">
    </div>
    <div class="control-group">
        <label for="zoom">Зум: <span id="zoomValue">1.0</span></label>
        <input type="range" id="zoom" min="1.0" max="1000.0" value="1.0" step="0.1">
    </div>
    <button id="resetButton">Сбросить положение</button>
    <div class="control-group">
        <label>Введите значение c:</label>
        <input type="text" id="cInput" placeholder="-0.7 + 0.27015i">
    </div>
</div>

<script>
    const canvas = document.getElementById('juliaCanvas');
    const ctx = canvas.getContext('2d');

    const cRealInput = document.getElementById('cReal');
    const cRealValue = document.getElementById('cRealValue');

    const cImagInput = document.getElementById('cImag');
    const cImagValue = document.getElementById('cImagValue');

    const iterationsInput = document.getElementById('iterations');
    const iterationsValue = document.getElementById('iterationsValue');

    const zoomInput = document.getElementById('zoom');
    const zoomValue = document.getElementById('zoomValue');

    const resetButton = document.getElementById('resetButton');

    const cInput = document.getElementById('cInput');

    let cRe = parseFloat(cRealInput.value);
    let cIm = parseFloat(cImagInput.value);
    let maxIterations = parseInt(iterationsInput.value);
    let zoom = parseFloat(zoomInput.value);
    let offsetX = 0;
    let offsetY = 0;

    function resizeCanvas() {
        canvas.width = window.innerWidth - document.getElementById('controls').offsetWidth;
        canvas.height = window.innerHeight;
        drawJuliaSet();
    }

    window.addEventListener('resize', resizeCanvas);

    function drawJuliaSet() {
        const width = canvas.width;
        const height = canvas.height;

        const imageData = ctx.createImageData(width, height);
        const data = imageData.data;

        const minRe = -2.0 / zoom + offsetX;
        const maxRe = 2.0 / zoom + offsetX;
        const minIm = -2.0 / zoom + offsetY;
        const maxIm = minIm + (maxRe - minRe) * height / width;

        const reFactor = (maxRe - minRe) / (width - 1);
        const imFactor = (maxIm - minIm) / (height - 1);

        for (let y = 0; y < height; y++) {
            const zIm = maxIm - y * imFactor;
            for (let x = 0; x < width; x++) {
                const zRe = minRe + x * reFactor;

                let Z_re = zRe, Z_im = zIm;
                let n = 0;
                let isInside = true;

                for (; n < maxIterations; n++) {
                    const Z_re2 = Z_re * Z_re;
                    const Z_im2 = Z_im * Z_im;

                    if (Z_re2 + Z_im2 > 4) {
                        isInside = false;
                        break;
                    }

                    Z_im = 2 * Z_re * Z_im + cIm;
                    Z_re = Z_re2 - Z_im2 + cRe;
                }

                const p = (y * width + x) * 4;
                if (isInside) {
                    data[p] = 0;
                    data[p + 1] = 0;
                    data[p + 2] = 0;
                } else {
                    const t = n / maxIterations;
                    const color = getColor(t);

                    data[p] = color.r;
                    data[p + 1] = color.g;
                    data[p + 2] = color.b;
                }
                data[p + 3] = 255;
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    function update() {
        cRe = parseFloat(cRealInput.value);
        cIm = parseFloat(cImagInput.value);
        maxIterations = parseInt(iterationsInput.value);
        zoom = parseFloat(zoomInput.value);

        cRealValue.textContent = cRe.toFixed(2);
        cImagValue.textContent = cIm.toFixed(2);
        iterationsValue.textContent = maxIterations;
        zoomValue.textContent = zoom.toFixed(1);

        drawJuliaSet();
    }

    cRealInput.addEventListener('input', update);
    cImagInput.addEventListener('input', update);
    iterationsInput.addEventListener('input', update);
    zoomInput.addEventListener('input', update);

    cInput.addEventListener('change', () => {
        const input = cInput.value.trim();
        const match = input.match(/^([-+]?[0-9]*\.?[0-9]+)\s*([+-])\s*([0-9]*\.?[0-9]+)i$/);
        if (match) {
            cRe = parseFloat(match[1]);
            cIm = parseFloat(match[3]);
            if (match[2] === '-') cIm = -cIm;

            cRealInput.value = cRe;
            cImagInput.value = cIm;
            cRealValue.textContent = cRe.toFixed(2);
            cImagValue.textContent = cIm.toFixed(2);

            drawJuliaSet();
        } else {
            alert('Некорректный формат. Пожалуйста, используйте формат: a + bi');
        }
    });

    resetButton.addEventListener('click', () => {
        offsetX = 0;
        offsetY = 0;
        zoom = 1.0;
        zoomInput.value = zoom;
        zoomValue.textContent = zoom.toFixed(1);
        drawJuliaSet();
    });

    function getColor(t) {
        const colors = [
            { r: 0, g: 7, b: 100 },
            { r: 32, g: 107, b: 203 },
            { r: 237, g: 255, b: 255 },
            { r: 255, g: 170, b: 0 },
            { r: 0, g: 2, b: 0 }
        ];

        const steps = colors.length - 1;
        const scaledT = t * steps;
        const idx1 = Math.floor(scaledT);
        const idx2 = Math.min(idx1 + 1, steps);
        const localT = scaledT - idx1;

        return interpolateColor(colors[idx1], colors[idx2], localT);
    }

    function interpolateColor(color1, color2, factor) {
        const result = {
            r: Math.round(color1.r + factor * (color2.r - color1.r)),
            g: Math.round(color1.g + factor * (color2.g - color1.g)),
            b: Math.round(color1.b + factor * (color2.b - color1.b))
        };
        return result;
    }

    let isDragging = false;
    let dragStartX, dragStartY;

    canvas.addEventListener('mousedown', function(e) {
        if (e.button === 0) {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
        }
    });

    canvas.addEventListener('mousemove', function(e) {
        if (isDragging) {
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;

            const width = canvas.width;
            const height = canvas.height;
            const minRe = -2.0 / zoom;
            const maxRe = 2.0 / zoom;
            const minIm = -2.0 / zoom;
            const maxIm = minIm + (maxRe - minRe) * height / width;

            const reFactor = (maxRe - minRe) / (width - 1);
            const imFactor = (maxIm - minIm) / (height - 1);

            offsetX -= dx * reFactor;
            offsetY += dy * imFactor;

            dragStartX = e.clientX;
            dragStartY = e.clientY;

            drawJuliaSet();
        }
    });

    canvas.addEventListener('mouseup', function(e) {
        if (e.button === 0) {
            isDragging = false;
        }
    });

    canvas.addEventListener('mouseleave', function(e) {
        isDragging = false;
    });

    canvas.addEventListener('wheel', function(e) {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const width = canvas.width;
        const height = canvas.height;
        const minRe = -2.0 / zoom + offsetX;
        const maxRe = 2.0 / zoom + offsetX;
        const minIm = -2.0 / zoom + offsetY;
        const maxIm = minIm + (maxRe - minRe) * height / width;

        const reFactor = (maxRe - minRe) / (width - 1);
        const imFactor = (maxIm - minIm) / (height - 1);

        const zRe = minRe + mouseX * reFactor;
        const zIm = maxIm - mouseY * imFactor;

        if (e.deltaY < 0) {
            zoom *= 1.1;
        } else {
            zoom /= 1.1;
        }

        if (zoom < 1) zoom = 1;
        if (zoom > 1000) zoom = 1000;

        zoomInput.value = zoom;
        zoomValue.textContent = zoom.toFixed(1);

        const newMinRe = -2.0 / zoom + offsetX;
        const newMaxRe = 2.0 / zoom + offsetX;
        const newMinIm = -2.0 / zoom + offsetY;
        const newMaxIm = newMinIm + (newMaxRe - newMinRe) * height / width;

        const newReFactor = (newMaxRe - newMinRe) / (width - 1);
        const newImFactor = (newMaxIm - newMinIm) / (height - 1);

        const newZRe = newMinRe + mouseX * newReFactor;
        const newZIm = newMaxIm - mouseY * newImFactor;

        offsetX += zRe - newZRe;
        offsetY += zIm - newZIm;

        drawJuliaSet();
    });

    resizeCanvas();

</script>

</body>
</html>
